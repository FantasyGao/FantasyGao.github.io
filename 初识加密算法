## 加密算法的意义
很简单，加密算法的出现正是为了解决万物互联下数据隐私与安全的问题，在畅游于网络之中时候，那便是数据在不停的交换和流动的时候，如果没有加密算法，我们的
各种密码，或者一些私密信息便在网络中“裸奔”，只要有攻击者去拦截你在交换数据时发出的请求操作，那便意味着你毫无私密可言。

## 加密算法的使用的场景
从我现在接触的技术来看，使用加密的场景其实并不是很多，因为互联网本来就是万物互联，信息共享为基础的，如很多的网站，出发点就是让人去阅读去了解它，但是你在
网站上做一些想要让其他人知道这个是你做的记录的时候，你便需要像现实生活中一样，创建一个网站身份证，这个操作就是你注册账号的过程，这时候会一个密码来让这个
账号只能让你登录，所以这个密码不能让其他人知道的，所以当你填写完密码提交的时候会发送一个加密后的串，提交给网站后台入库，为了安全不被脱库，网站只会存这个
串，所以这个密码一般是除了你连网站人员也不知道的，这就是你忘了密码后，只能改，不能找回的原因。这种加密方式是不可解密的。还是注册这个过程，很多时候我们都
是填手机号注册的，但是把用户存入数据库也是很不安全的，所以这时候还需要将手机号码加密后存进去，但是存入手机号后，网站一般需要给你发验证码什么的，这肯定不
能像加密密码那种不能解密的方式，这个时候就需要能够解密出来的算法，一般在这个环节，后台会使用对称加密算法加密你的手机号入库，这个操作是需要一个加密秘钥的，
当要给你发一些营销信息等等的时候，再用该密钥解密出来就可以了。

不需要解密的算法有很多种，如md5，sha1,sha0, sha256, sha384等，下面举几个例子
```
// node.js
require('crypto').createHash('md5'|'sha'|'sha1'|'sha256').update('password', 'utf8').digest('hex');
// mysql
select MD5|SHA|SHA1('password');
select SHA2('password', 256| 384 | 512);
```
如上都可以达到加密的效果，至于各种方式的差别来说，md5和sha，sha1在目前来说已经在高标准加密的场合被启用了，例如以前github的log是sha1的，后来更换到了
sha256，因为位数较短，在运算越来越快的计算机环境下，逆向破解的过程也被加快，从而变得不安全。说明一下，上述的任何加密算法都是有可能被逆向破解出来的，只
是运算力够不够，运算的时间长不长的问题。因为加密之后的结果终归是有限结果集，就如256位的sha2算法，他有2的256次方的结果，当你枚举完后所有结果，是不是就
会有一种和你输入的密码达到同样的效果，从而冒充你登录网站不安全呢，当然目前这很难做到，所以说这个算法在现在是很安全的。

对称加密的算法，DES、TripleDES、RC2、RC4、RC5和Blowfish等（只用过DES），还有用过shadowsocks的同学一定知道选method这个的时候要选择一个算法为你
的数据加密，在那里的算法都是对称加密方式的。如下代码为对称加密例子
```
// node.js
require('mysql-aes').encrypt('手机号码', 'my-key');
require('mysql-aes').decrypt('480AE3E13FA619C5CBF3921E447A6C79', 'my-key');
// mysql
select des_decrypt(DES_ENCRYPT('手机号码', 'my-key'), 'my-key')
```

当我们在注册的过程中，甚至连手机号都不想暴露，但是又不能使用对称加密，因为对称加密需要秘钥协作完成，此时我们就需要一种新的方式完成，首先要使得前端传输的
数据加密，其次注册信息在后台还要能解析开，这时候就需要两把钥匙，一把能够公开的，一把不能公开的，它两必须是一对一的，客户端拿到公开的钥匙将数据加密，返回
至服务端，服务端拿私有的钥匙解开数据，完成过程，该过程就叫做非对称加密。


